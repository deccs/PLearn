#!/usr/bin/perl -w

## This file is a modification made to the file apdispatch by Frederic Bastien
## To make it use dbi.py to launch many experience in one command line
## condordispatch

## Copyright (C) 2004 ApSTAT Technologies Inc. 
##
## Redistribution and use in source and binary forms, with or without
## modification, are permitted provided that the following conditions are met:
## 
##  1. Redistributions of source code must retain the above copyright
##     notice, this list of conditions and the following disclaimer.
## 
##  2. Redistributions in binary form must reproduce the above copyright
##     notice, this list of conditions and the following disclaimer in the
##     documentation and/or other materials provided with the distribution.
## 
##  3. The name of the authors may not be used to endorse or promote
##     products derived from this software without specific prior written
##     permission.
## 
## THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR
## IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
## OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
## NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
## SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
## TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
## PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
## LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
## NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
## SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
## 
## This file is part of the PLearn library. For more information on the PLearn
## library, go to the PLearn Web site at www.plearn.org

if (scalar(@ARGV) == 0) {
    die <<EOUSAGE
Usage: dbidispatch [--req="CONDOR_REQUIREMENT"]<command-template>
Dispatches jobs on Condor with dbi.py.  

where <command-template> is interpreted as follows: the first argument
is the <command> above, and the rest are interpreted as <arguments>.
The arguments may contain segments of the form {{a,b,c,d}}, which trigger
parallel dispatch: a separate "cluster --execute" command is issued for
the rest of the command template, the first time with value a, the second
time with value b, etc.  For example, the command (NOTE: THERE MUST NOT
BE ANY SPACES WITHIN THE "numhidden={{5,10,25}}" part and the quotes are
important to avoid shell misinterpretation) :

  dbidispatch aplearn myscript.plearn "numhidden={{5,10,25}}"

is equivalent to launching three jobs in parallel on the cluster:

  aplearn myscript.plearn numhidden=5
  aplearn myscript.plearn numhidden=10
  aplearn myscript.plearn numhidden=25

If several arguments contain {{ }} forms, all combinations of arguments
are taken, and the jobs are all launched in parallel.  For instance

  dbidispatch aplearn myscript.plearn "numhidden={{10,25}}" "wd={{0.01,0.001}}"

is equivalent to:

  aplearn myscript.plearn numhidden=10 wd=0.01
  aplearn myscript.plearn numhidden=10 wd=0.001
  aplearn myscript.plearn numhidden=25 wd=0.01
  aplearn myscript.plearn numhidden=25 wd=0.001

EOUSAGE
}

if (substr($ARGV[0],0,6) eq "--req=") {
    $REQ = substr($ARGV[0],6);
    shift;
} elsif (substr($ARGV[0],0,1) eq '-'){
    die "Unknow parameter $ARGV[0]\n";
} else {
    $REQ = "";
}

$command_name = shift;
### Find replacement lists in the arguments
my @repl = ();
foreach my $arg (@ARGV) {
    $arg =~ /{{(.*)}}/;
    my @curargs = ("");
    @curargs = split(",",$1) if $arg =~ /{{(.*)}}/;
    push @repl, \@curargs;
}

#print $command_name, "\n";
#for ($i=0; $i < scalar(@ARGV); ++$i) {
#    print "Root = ", $ARGV[$i],
#    "\tArglist = (", join(",",@{$repl[$i]}),")\n";
#}
$ScriptName="lauchdbi.py";
open(SCRIPT,">$ScriptName");
print SCRIPT "#! /usr/bin/env python\n".
    "from plearn.parallel.dbi import DBI\n".
    "jobs = DBI([\n";
my @idx = (0) x @ARGV;

if(scalar(@ARGV) == 0){
    print SCRIPT "'$command_name'\n";
} else {
    while ($idx[$#idx] < scalar(@{$repl[$#idx]})) {
	### Compute current argument list
	my @curargs;
	for (my $i=0; $i < scalar(@idx); ++$i) {
	    my $arg = $ARGV[$i];
	    if ($arg =~ /{{.*}}/) {
		my $value = ($repl[$i])->[$idx[$i]];
		$arg =~ s/{{.*}}/$value/;
	    }
	    push @curargs, $arg;
	}
	### Two passes are necessary to properly increment
	for (my $i=0; $i < scalar(@idx); ++$i) {
	    $idx[$i]++;
	    last if $idx[$i] < scalar(@{$repl[$i]}) || $i == $#idx;
	    $idx[$i] = 0;
	}
	
	
	###There are two distinct steps: command creation and command execution
	### Command creation depending on cluster or direct launch:
	$cmdstr = "$command_name " . join(" ",@curargs);
	print SCRIPT "'$cmdstr',\n";
	
    }
}

print SCRIPT "   ],'Condor'";

if ($REQ ne "") {
    print SCRIPT ", requirements=\"$REQ\"";
}

print SCRIPT ")\n".
    "jobs.run() \n";

close(SCRIPT);
system("chmod +x $ScriptName");
print "Launching newly created script $ScriptName\n";
system("./$ScriptName");
