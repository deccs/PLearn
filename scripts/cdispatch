#!/usr/bin/env python
import sys,os,re,time,datetime

ScriptName="launchdbi.py"
ShortHelp='Usage: cdispatch [--help|-h] [--log|*--nolog] [--cluster|--local[=nb_process]|*--condor] [--test] [--duree=X] [--wait] [--req="CONDOR_REQUIREMENT"] [--32|--64|--3264] {--file=FILEPATH | <command-template>} \n An * before -- mean that it is the default'
LongHelp="""
Dispatches jobs with dbi.py. dbi allow to dispatch jobs on condor, cluster, local, ssh and bqtools.

%s

parameter only for cluster:--duree,--wait,--3264,--32,--64
parameter only for condor:--req=X

where <command-template> is interpreted as follows: the first argument
is the <command> above, and the rest are interpreted as <arguments>.
The arguments may contain segments of the form {{a,b,c,d}}, which trigger
parallel dispatch: a separate 'cluster --execute' command is issued for
the rest of the command template, the first time with value a, the second
time with value b, etc.  For example, the command (NOTE: THERE MUST NOT
BE ANY SPACES WITHIN THE 'numhidden={{5,10,25}}' part and the quotes are
important to avoid shell misinterpretation) :

  dbidispatch aplearn myscript.plearn 'numhidden={{5,10,25}}'

is equivalent to launching three jobs in parallel on the cluster:

  aplearn myscript.plearn numhidden=5
  aplearn myscript.plearn numhidden=10
  aplearn myscript.plearn numhidden=25

If several arguments contain {{ }} forms, all combinations of arguments
are taken, and the jobs are all launched in parallel.  For instance

  dbidispatch aplearn myscript.plearn 'numhidden={{10,25}}' 'wd={{0.01,0.001}}'

is equivalent to:

  aplearn myscript.plearn numhidden=10 wd=0.01
  aplearn myscript.plearn numhidden=10 wd=0.001
  aplearn myscript.plearn numhidden=25 wd=0.01
  aplearn myscript.plearn numhidden=25 wd=0.001

The optional parameter '--test' make that cdispatch generate the file $ScriptName, but do not execute it. That way you can see what cdispatch generate.

The optional parameter '--req=\"CONDOR_REQUIREMENT\"' make that cdispatch send additional option to DBI that will be used to generate addtional requirement for condor. CONDOR_REQUIREMENT must follow the syntax of requirement for condor with one exception. The symbol '\"' must be escaped 3 times! So the requirement (Machine == \"computer.example.com\") must be writed like that:

cdispatch \"--req=Machine==\\\\\\\"computer.example.com\\\\\\\"\"
or
cdispatch '--req=Machine==\\\"computer.example.com\\\"' 

If the optinal parameter '--file=FILEPATH' is set, the script will take commands from the file instead of taking one as parameter. This file must have one command to execute by line and each of them will be expended.

cdispatch --test --file=tests

In the file, there must not be double quotes around the {{}} as they are for the shell and if the command is in the file, they are not interpreted by the shell.
"""%ShortHelp

if len(sys.argv) == 1:
    print ShortHelp
    sys.exit(1)
optionargs = []
otherargs = []
FILE = ""
dbi_param={}

for argv in sys.argv[1:]:

    if argv == "--help" or argv == "-h":
        print LongHelp
        sys.exit(1)
    elif argv == "--nolog":
        dbi_param["dolog"]=False
    elif argv == "--log":
        dbi_param["dolog"]=True
    elif argv == "--cluster":
        optionargs.append(argv[2:])
    elif argv == "--condor":
        #it is the default
        optionargs.append(argv[2:])
    elif argv.startswith("--duree="):
        dbi_param["duree"]=argv[8:]
    elif argv.startswith("--local"):
        optionargs.append(argv[2:7])
        if len(argv)>7:
            assert(argv[7]=="=")
            NB_PROC=argv[8:]
            dbi_param["nb_proc"]=argv[8:]
    elif argv == "--test":
        dbi_param["test"]=True
    elif argv.startswith("--file="):
        FILE = argv[7:]
        optionargs.append(argv[2:])
    elif argv == "--32"  or argv == "--64" or argv == "--3264":
        dbi_param["arch"]=argv[2:]
    elif argv == "--wait":
        dbi_param["wait"]=True
    elif argv[0:6] == "--req=":
        dbi_param["requirements"]="\"%s\""%argv[6:]
    elif argv[0:1] == '-':
	print "Unknow parameter (%s)",argv
	print ShortHelp
        sys.exit(1)
    else:
        otherargs.append(argv)
        
if len(otherargs) == 0 and FILE == "":
    print ShortHelp
    sys.exit(1)


if "local" in optionargs and "cluster" in optionargs:
    print "--cluster and --local can't be used together"
    sys.exit(1)

def generate_combination(repl):
    if repl == []:
        return []
    else:
        res = []
        x = repl[0]
        res1 = generate_combination(repl[1:])
        for y in x:
            if res1 == []:
                res.append(y)
            else:
                for r in res1:
                    res.append(y+" "+r)
        return res

def generate_commands(sp):
### Find replacement lists in the arguments
    repl = []
    for arg in sp:
        p = re.compile('\{\{\S*\}\}')
        reg = p.search(arg)
        if reg:
#            print "reg:",reg.group()[2:-2]
            curargs = reg.group()[2:-2].split(",")# if arg =~ /{{(.*)}}/
#            print "curargs:",curargs
            newcurargs = []
            for curarg in curargs:
                new = p.sub(curarg,arg)
#                print "new:",new
                newcurargs.append(new)
            repl.append(newcurargs)
        else:
            repl.append([arg])
#    print "repl: ",repl
    argscombination = generate_combination(repl)
    return argscombination

#generate the command
if FILE != "":
    FD = open(FILE,'r')#|| die "couldn't open the file $FILE!";
    for line in FD.readlines():
        line = line.rstrip()
	sp = line.split(" ")
        commands=generate_commands(sp)
    FD.close
else:
    commands=generate_commands(otherargs)

if "cluster" in optionargs:
    launch_cmd='Cluster'
elif "local" in optionargs:
    launch_cmd='Local'
else:
    launch_cmd='Condor'

    
t = [x for x in sys.argv[1:] if not x[:2]=="--"]
t[0]=os.path.split(t[0])[1]
tmp="_".join(t)
tmp=re.sub( '[^a-zA-Z0-9-.,]', '_', tmp )
tmp+=str(datetime.datetime.now()).replace(' ','_')
print "tmp:",tmp
dbi_param["log_dir"]=os.path.join("LOGS",tmp)
dbi_param["log_file"]=os.path.join(dbi_param["log_dir"],'log')

if "test" in dbi_param:
    print "We generated %s command in the file"% len(commands)
    print "The script %s was not launched"% ScriptName
    SCRIPT=open(ScriptName,'w');
    SCRIPT.write(
"""#! /usr/bin/env python
#%s
from plearn.parallel.dbi import DBI
jobs = DBI([
"""% " ".join(sys.argv))
    for arg in commands:
        cmdstr = "".join(arg);
        SCRIPT.write("   '%s',\n"%cmdstr)
    SCRIPT.write("   ],'%s'"%(launch_cmd))
    for key in dbi_param.keys():
        if isinstance(dbi_param[key],str):
            SCRIPT.write(","+str(key)+"='"+str(dbi_param[key])+"'")
        else:
            SCRIPT.write(","+str(key)+"="+str(dbi_param[key]))
    SCRIPT.write(
""")
jobs.run()
# There is %d command in the script"""%(len(commands)))
        
    SCRIPT.close()
    os.system("chmod +x %s"%(ScriptName));

else:
    print "We generate the DBI object with %s command"%(len(commands))
    from plearn.parallel.dbi import *
    print time.ctime()
    t1=time.time()
    jobs = DBI(commands,launch_cmd,**dbi_param)
    t2=time.time()
    print "it took %f s to create the DBI objects"%(t2-t1)
    jobs.run()
    t3=time.time()
    print "it took %f s to launch all the commands"%(t3-t2)

