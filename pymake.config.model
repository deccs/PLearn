#!python
   
#############################################################################################################
## WARNING                                                                                                  #
#  if you add options don't forget to add in the pymake file                                                #
#       optionargs.remove('myoption')                                                                       #
#  If you don't, because of the follwing pymake command                                                     #
#       #Building name of object subdirectory                                                               #
#       objsdir = join('OBJS', platform + '__' + string.join(options,'_'))                                  #
#       print '*** Running pymake using following options: ' + string.join(map(lambda o: '-'+o, options))   #
# you will create useless OBJS repertory                                                                    #
# (unless the option changes the resulting OBJS files)                                                      #
#############################################################################################################

import os, os.path
from plearn.utilities.ppath import ppath
from plearn.utilities.svn   import repository_revision

# Qt Specific stuff

qtdir = '/usr/lib/qt-3.1/'

# PLearn specific directories:

# New: The PPath configuration file contains all PLearn relative settings
plearndir = ppath('PLEARNDIR')
libdir    = ppath('PLEARN_LIBDIR')

# Force use of ssh @ Apstat & Lisa
domain_name = socket.getfqdn();
if domain_name.endswith('apstat.com') or domain_name.endswith('iro.umontreal.ca'):
    rshcommand= 'ssh -x'

nice_value = '1'

# to get more or less verbosity (currently verbose in {1,2,3,4})
# 1 -> get *** Running ... / ++++ Computing
# 2 -> get Launched / Finished / Still waiting
# 3 -> get lauched command (default)
# 4 -> get extra information
verbose = 3;

# List of directories in which to look for .h includes and corresponding .cc files to compile and link with your program
# (no need to include the current directory, it is implicit)
sourcedirs = [ plearndir ]

# will be added as list of includes (-I...) to all compilations
mandatory_includedirs = []

# The platform variable contains the type of platform from which pymake has been invoked. 
# This is something like 'linux-i386', 'linux-alpha', 'sunos5', 'irix6', 'irix6-n32' etc...
# Feel free to use it to adapt configuration to that platform.


# (sys.byteorder does not exist in older versions of python)
if platform=='linux-i386':
    compileflags = '-DLINUX -DLITTLEENDIAN'
#    compileflags = '-DLINUX -DLITTLEENDIAN -mcpu=i686 -march=i686 -ftemplate-depth-100'
elif platform=='linux-ppc':
    compileflags = '-DLINUXPPC -DBIGENDIAN'
elif platform=='linux-alpha':
    compileflags = '-DSPARC -DBIGENDIAN'
elif platform=='linux-ia64':
    compileflags = '-DLINUX -DLITTLEENDIAN'
elif platform=='linux-x86_64':
    compileflags = '-DLINUX -DLITTLEENDIAN'
elif platform=='sunos5' :
    compileflags = '-DSPARC -DBIGENDIAN'
elif platform=='irix6'  :
    compileflags = '-DSGI -DBIGENDIAN'
elif platform=='irix6-n32' :
    compileflags = '-DSGI -DBIGENDIAN'
elif platform=='win32' :
    compileflags = '-DWIN32 -D_MINGW_ -DLITTLEENDIAN'
elif platform=='darwin' :
    compileflags = '-DDARWIN -DBIGENDIAN -fno-coalesce'
else:
    print 'Unknown platform: ' + platform
    sys.exit()

#################################################################
## DBDIR and METADBDIR should be moved to PLEARN_CONFIGS soon  ##
#################################################################
# If the DBDIR environment variable is not defined, we use the default "/u/lisa/Database"
dbdir = os.environ.get('DBDIR','/u/lisa/Database')
compileflags = compileflags + ' -DDBDIR=\\"' + dbdir + '\\"' 
# If the METADATADIR environment variable is not defined, we use the default "/u/lisa/db/metadata"
metadatadir = os.environ.get('METADATADIR','/u/lisa/db/metadata')
compileflags = compileflags + ' -DMETADATADIR=\\"' + metadatadir + '\\"' 
#################################################################
#################################################################


#####  Repository Revision String Generation  ###############################

def PL_repository_revision():
    return PL_default_repository_revision()

def PL_default_repository_revision():
  from plearn.utilities.version_control import update_repository_revision
  return "PL" + update_repository_revision('plearn', plearndir,
                                           os.path.join(ppath('HOME'), '.plearn'),
                                           os.path.join( plearndir, "plearn", "base",
                                                  "pl_repository_revision.cc" ))

optionalLibrary( name = 'plearn_repository_revision',
                 triggers = 'pl_repository_revision.h',
                 compileroptions = [ '-DPL_REPOSITORY_REVISION=\\"', PL_repository_revision, '\\"' ],
                 linkeroptions   = '')


#####  Optional Libraries  ##################################################

# Add available external libraries In the order in which the linkeroptions
# must appear on the linker command line (typically most basic libraries
# last) If you do not give any specific triggers, any included .h file
# found in the specified includedirs will trigger the library Triggers can
# be a list of includes that will trigger the use of the library, and they
# can have wildcards (such as ['GreatLibInc/*.h','Magick*.h'] for instance)

optionalLibrary( name = 'xml',
                 includedirs = [os.path.join(libdir,'xml/gcc_3.2/xerces-c-src2_1_0/include'), 
                                os.path.join(libdir,'xml/gcc_3.2/xerces-c-src2_1_0/include/xercesc'), 
                                os.path.join(libdir,'xml/gcc_3.2/xml-xalan/c/src')],
                 linkeroptions = (' -Xlinker -rpath -Xlinker ' +
                                  os.path.join(libdir,'xml/gcc_3.2/xerces-c-src2_1_0/lib') +
                                  ' -Xlinker -rpath -Xlinker ' +
                                  os.path.join(libdir,'xml/gcc_3.2/xml-xalan/lib') + ' -L' +
                                  os.path.join(libdir,'xml/gcc_3.2/xerces-c-src2_1_0/lib') + ' -L' +
                                  os.path.join(libdir,'xml/gcc_3.2/xml-xalan/lib') + ' -lxalan-c1_4_0 -lxerces-c' ) )

optionalLibrary( name = 'xml-apstat',
                 includedirs = ['/usr/include/xercesc', '/usr/include/xalanc'],
                 linkeroptions = ( ' -lxalan-c -lxerces-c' ) )
                                  

#optionalLibrary( name = 'wxwindows',
#                 triggers = 'wx/*.h',        
#                 includedirs = ['/u/lisa/local/linux-i386/Install/wxWindows/wxGTK-2.2.9/lib/wx/include/gtk-2.2', '/u/lisa/local/linux-i386/Install/wxWindows/wxGTK-2.2.9/include','/usr/include/gtk-1.2', '/usr/include/glib-1.2', '/usr/lib/glib/include', '/usr/X11R6/include'],
#                 compileroptions = '-DwxINSTALL_PREFIX=\"/u/lisa/local/linux-i386/\"  -D__WXGTK__ -DGTK_NO_CHECK_CASTS -D_REENTRANT -MMD -Wno-long-long',
#                 linkeroptions = '/u/lisa/local/linux-i386/Install/wxWindows/wxGTK-2.2.9/lib/libwx_gtk-2.2.so.6.2.6 -L/usr/lib -L/usr/X11R6/lib -lgtk -lgdk -rdynamic -lgmodule -lgthread -lglib -lpthread -ldl -lXi -lXext -lX11 -lm  -lpng -ljpeg -ltiff  -ldl -lpthread -lz -lm' )


optionalLibrary( name = 'arpack',
                 triggers = 'arpack_proto.h',
                 linkeroptions = '-L'+ libdir +'/ARPACK/OBJS/' + target_platform + ' -larpack' )

# Note: now blas and lapack are together.
#optionalLibrary( name = 'lapack',
#                 triggers = 'lapack_proto.h',
#                 linkeroptions = lapack_linkeroptions 
#                 )

optionalLibrary( name = 'opengl',
                 triggers = 'GL/gl.h',
                 linkeroptions = '-lGL -lGLU -lglut'
                 )


# optionalLibrary( name = 'blas',
#                 triggers = ['blas_proto.h','lapack_proto.h'],
#                 linkeroptions = '-lblas'
#                 linkeroptions = '-L' + libdir + '/intelmkl/lib/32 -lmkl_p4 -lmkl_vml_p4 -lpthread'
#                 linkeroptions = '-L' + libdir + '/intelmkl/lib/32 -lmkl_p3 -lmkl_vml_p3 -lpthread'
#                 linkeroptions = '-L' + libdir + '/intelmkl/lib/32 -lmkl -lvml -lpthread'
#                 linkeroptions = '-L' + libdir + '/atlas_athlon256 -lcblas -lf77blas -latlas'
#                 )

# optionalLibrary( name = 'g2c',
#                 triggers = ['blas_proto.h','lapack_proto.h'],
#                 linkeroptions = '-lg2c'
#                 )

optionalLibrary( name = 'ncurses',
                 triggers = 'curses.h',
                 linkeroptions = '-lncurses'
                 )

optionalLibrary( name = 'wordnet',
                 triggers = 'wn.h',
                 includedirs = '/u/lisa/WordNet/v2.0/include',
                 linkeroptions = '-L /u/lisa/WordNet/v2.0/lib -lwn'
                 )

optionalLibrary( name = 'X',
                 triggers='?',
                 includedirs = '?',
                 linkeroptions = '-L/usr/X11R6/lib/ -lXi -lXext -lX11'
)

### Using Python code snippets in C++ code
if domain_name == 'iro.umontreal.ca':
    numpy_includedirs   = [ '/u/lisa/local/linux-i386/include/' ]
    numpy_site_packages = '/u/lisa/local/linux-i386/lib/python2.3/site-packages/numarray -lutil'
else:
    numpy_includedirs   = []
    numpy_site_packages = '/usr/lib/python2.3/site-packages/numarray' 

optionalLibrary( name = 'python',
                 triggers = '[Pp]ython*',
                 includedirs = numpy_includedirs,
                 linkeroptions = ( '-L%s -lnumarray ' % numpy_site_packages + 
                                   '-L/usr/lib/python2.3/config -lpython2.3 ' +
                                   '-Xlinker -export-dynamic ' + 
                                   '-Xlinker -rpath -Xlinker %s' % numpy_site_packages )
                 )

# Operating system as defined by Torch when creating libraries.
if platform=='win32': ## os.uname is not defined under Windows...
  os.uname = lambda: ('Win32',)
torch_os = os.uname()[0]

# Base for the directory where we can find the Torch library.
torch_libdir = join(libdir, 'torch/' + torch_os + '_')

# Torch defines USE_DOUBLE when using real <=> double, and DEBUG in debug mode.
# The directory in which the library is stored is 'torch_os'_<dbg/opt>_<float/double>
torch_compiler_options = ''
if usingOpt:
  # Optimized mode.
  torch_libdir += 'opt_'
else:
  # Debug mode.
  torch_libdir += 'dbg_'
  torch_compiler_options += '-DDEBUG '

if usingFloat:
  # real <=> float
  torch_libdir += 'float'
else:
  # real <=> double
  torch_libdir += 'double'
  torch_compiler_options += '-DUSE_DOUBLE '

optionalLibrary( name = 'torch',
                 triggers = 'torch/*',
                 linkeroptions = '-L' + torch_libdir + ' -ltorch',
                 compileroptions = torch_compiler_options
               ) 

optionalLibrary( name='boost',
                 triggers = 'boost*',
#                 includedirs = libdir + '/../include',  ## You don't need it if you set CPATH environment 
#                 linkeroptions = '-L'+libdir            ## Systematically added in linkeroptions_tail
                 linkeroptions = ''
)

optionalLibrary( name='boost_date_time',
                 triggers = 'boost/date_time*',
                 linkeroptions = '-lboost_date_time' )

optionalLibrary( name='boost_filesystem',
                 triggers = 'boost/filesystem*',
                 linkeroptions = '-lboost_filesystem' )

optionalLibrary( name = 'boost_python',
                 triggers = 'boost/python.hpp',
                 includedirs = '/usr/include/python2.3',
                 linkeroptions = '-lboost_python'
                 )

optionalLibrary( name='boost_regex',
                 triggers = 'boost/regex*',
                 linkeroptions = '-lboost_regex' )

optionalLibrary( name='boost_signals',
                 triggers = 'boost/signals*',
                 linkeroptions = '-lboost_signals' )

optionalLibrary( name='boost_thread',
                 triggers = 'boost/thread*',
                 linkeroptions = '-lboost_thread' )

optionalLibrary( name = 'NSPR',
                 triggers = 'mozilla/nspr/*',
                 linkeroptions = '-L/usr/lib/mozilla -lnspr4')

# What linker options to put always after those from the optional libraries
linkeroptions_tail = '-L' + libdir + ' -lm'

# List of lists of mutually exclusive pymake options.
# First option that appears in each group is the default, and is assumed if you don't specify any option from that group
options_choices = [
  [ 'g++', 'g++3', 'icc', 'mpi', 'purify', 'quantify' ],
  [ 'dbg', 'opt', 'pintel', 'gprof', 'safegprof', 'safeopt', 'checkopt' ],
  [ 'double', 'float' ],
  [ 'throwerrors', 'exiterrors' ], 
  [ 'blas', 'p3blas','p4blas','athlonblas','pentiumblas', 'mammouthblas', 'noblas', 'veclib', 'scs'],
]


# Description of options, and associated settings

pymakeOption( name = 'g++',
              description = 'compiling with g++, with no MPI support',
              compiler = 'g++',
              compileroptions = '-Wno-deprecated -pedantic -DUSING_MPI=0 -Wno-long-long -ftemplate-depth-100',
              linker = 'g++' )

pymakeOption( name = 'g++3',
              description = 'compiling with g++3 (version 3.0), with no MPI support',
              compiler = 'g++3',
              compileroptions = '-Wno-deprecated -pedantic -DUSING_MPI=0  -ftemplate-depth-100',
              linker = 'g++3' )

pymakeOption( name = 'icc',   # For C++, it is actually icpc
              description = 'compiling with Intel Compiler (version 8.0), with no MPI support',
              compiler = 'icpc -w1 -wd981 -wd383 -wd869 -wd444 -wd810 -wd1418 -wd654',
              compileroptions = '-DUSING_MPI=0 ',
              linker = 'icpc  '
						)

pymakeOption( name = 'mpi',
              description = 'compiling and linking with MPI support (and USING_MPI=1)',
              compiler = 'mpiCC',               
              compileroptions = '-DUSING_MPI=1 -ftemplate-depth-100',
              linker = 'mpiCC' )

pymakeOption( name = 'purify',
              description = 'compiling and linking with purify g++',
              compiler = 'purify -g++ g++',               
              compileroptions = '-DUSING_MPI=0 -ftemplate-depth-100',
              linker = 'purify -g++ g++' )

pymakeOption( name = 'quantify',
              description = 'compiling and linking with quantify g++',
              compiler = 'quantify -g++ g++',               
              compileroptions = '-DUSING_MPI=0 -ftemplate-depth-100',
              linker = 'quantify -g++ g++' )

pymakeOption( name = 'dbg',
              description = 'debug mode',
              compileroptions = '-Wall -g -O0 -DBOUNDCHECK' )

#pymakeOption( name = 'wx',
#              description = 'wxWindos support',
#              compileroptions = '
    

# is -fomit-frame-pointer helping?
# does -malign-double indeed create core-dumps?
# is -finline hurting?
# is -funroll-loops hurting?

# TODO What is this ?
if usingIntelCompiler:
    pymakeOption( name = 'opt',
                  description = 'optimized for intel compiler',
                  compileroptions = '-Wall -O3 -DNDEBUG' )
else:
    pymakeOption( name = 'opt',
                  description = 'optimized mode',
                  compileroptions = '-Wall -O3 -DNDEBUG');

pymakeOption( name = 'pintel',
              description = 'parallelized for intel compiler',
              compileroptions = '-O3 -parallel -DNDEBUG');

pymakeOption( name = 'safeopt',
              description = 'safe optimized mode (includes bound checking)',
              compileroptions = '-Wall -O3 -DBOUNDCHECK' )

pymakeOption( name = 'checkopt',
              description = 'some variation on optimized mode',
              compileroptions = '-Wall -O3 -funroll-loops' )
  
### Same optimization options as -opt
pymakeOption( name = 'gprof',
              description = 'optimized mode with profiler support (-pg)',
              compileroptions = '-Wall -O3 -pg -DNDEBUG',
              linkeroptions = '-pg' )

pymakeOption( name = 'safegprof',
              description = 'safe optimized mode with profiler support (-pg)',
              compileroptions = '-Wall -O3 -DBOUNDCHECK -pg',
              linkeroptions = '-pg' )

lapack_linkeroptions = '-llapack'
blas_linkeroptions = '-lblas -lg2c'

# Jasmin : In OS X, there is a framework with blas and lapack
#if platform=='darwin':
#    lapack_linkeroptions = '-L/sw/lib/ -llapack'
if platform=='darwin':
    blas_linkeroptions = '-framework vecLib'
    lapack_linkeroptions = ''
#    blas_linkeroptions = '-L/sw/lib/ -lcblas -lf77blas -latlas -lg2c'

pymakeOption( name = 'noblas',
              description = 'compilation and linking without BLAS',
              #linkeroptions = '-lg2c'              
              )

pymakeOption( name = 'blas',
              description = 'compilation and linking basic BLAS',
              compileroptions = '-D USE_BLAS_SPECIALISATIONS',
              linkeroptions = blas_linkeroptions + ' ' + lapack_linkeroptions
              )

pymakeOption( name = 'pentiumblas',
              description = 'compilation and linking BLAS for Intel Pentium processor',
              compileroptions = '-D USE_BLAS_SPECIALISATIONS',
              linkeroptions = '-L' + libdir +'/intelmkl/lib/32 -lmkl -lvml -lpthread -lg2c')

pymakeOption( name = 'p3blas',
              description = 'compilation and linking BLAS for Intel Pentium 3 processor',
              linkeroptions = '-L'+ libdir + '/intelmkl/lib/32 -lmkl_p3 -lmkl_vml_p3 -lpthread -lg2c')

pymakeOption( name = 'athlonblas',
              description = 'compilation and linking atlas BLAS for AMD Athlon processor',
              compileroptions = '-D USE_BLAS_SPECIALISATIONS',
              linkeroptions = '-L' + libdir + '/atlas_athlon256 -lcblas -lf77blas -latlas -lg2c')

pymakeOption( name = 'p4blas',
              description = 'compilation and linking BLAS for Intel Pentium 4 processor',
              compileroptions = '-D USE_BLAS_SPECIALISATIONS',
              linkeroptions = '-L' + libdir + '/intelmkl/lib/32 -lmkl_p4 -lmkl_vml_p4 -lpthread -lg2c')

pymakeOption( name = 'mammouthblas',
    description = 'compilation and linking BLAS for P4 Mammouth-Serie cluster',
    compileroptions = '-D USE_BLAS_SPECIALISATIONS',
    linkeroptions = '-L/opt/mkl/lib/32 -lmkl_p4 -lmkl_vml_p4 -lpthread -lmkl_lapack')

pymakeOption( name = 'veclib',
              description = "Apple's vecLib library, a version of the BLAS library for the G4 and G5 under OS X",
              compileroptions = '-D USE_BLAS_SPECIALISATIONS',
              linkeroptions = '-framework vecLib')

pymakeOption( name = 'scs',
              description = "BLAS and lapack intel super optimized library",
              compileroptions = '-D USE_BLAS_SPECIALISATIONS',
              linkeroptions = '-lscs')

pymakeOption( name = 'float',
              description = 'float mode (real==float)',
              compileroptions = '-DUSEFLOAT')

pymakeOption( name = 'double',
              description = 'double mode (real==double)',
              compileroptions = '-DUSEDOUBLE')

pymakeOption( name = 'throwerrors',
              description = 'defines the USE_EXCEPTIONS flag so that PLERROR throws an exception (?)',
              compileroptions = '-DUSE_EXCEPTIONS' )

pymakeOption( name = 'exiterrors',
              description = 'PLERROR will not throw exceptions, but write the error message and exit' )

pymakeOption( name = 'spc',
              description = 'Use of Smart Parallel Compilation')
              
              
nprocesses_per_processor = 1

# LISA hack to set the number of processes per processor on a 'machine name' basis
if myhostname[0:5]=='troll':
    nprocesses_per_processor = 16
if myhostname[0:4]=='zeus':
    nprocesses_per_processor = 18
if myhostname[0:6]=='canari':
    nprocesses_per_processor = 2
if myhostname[0:7]=='frontal':
    nprocesses_per_processor = 4
if myhostname[0:6]=='merlin':
    nprocesses_per_processor = 1
