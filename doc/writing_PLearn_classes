
---+++ Structure of PLearn high-level classes

There are two types of classes in the PLearn Library:
   * high-level classes that can be manipulated by the user through a script
   * low-level classes that can't be manipulated by the user through a script

The latter are often used as auxiliary classes for the former. The subject of
the discussion here are the high-level classes, and how they should be structured
so that the following functionalities are properly provided:
   * user-accessible documentation
   * access and construction through a script
   * streaming and serialization
   * general class utilities (e.g. classname(), etc...)

The best way to show the required structure is to go through an empty example
(which can be generated by typing 'pyskeleton Object Toto'). The pyskeleton will
produce other features not discussed much here, such as:
   * the copyright / distribution notice header
   * the class definition framework, including
   * calls to macros PLEARN_DECLARE_OBJECT (in the class definition)
     and PLEARN_OBJECT_PTR (outside the class definition), which only
     take the class name as argument. They define and declare automatically a 
     number of things necessary for achieving the above goals.
   * the declaration of the build, build_, makeDeepCopyFromShallowCopy, declareOptions,
     an empty constructor (THERE IS NO NEED TO WRITE ANYTHING BUT AN EMPTY CONSTRUCTOR,
     which initialises the variable, since the actual contruction is done in build_/build).
   * the declaration 'typedef <superclass> inherited;' (with <superclass> the
     appropriate name, e.g. Object with our Toto example).

The main points to remember are the following:

   * in Toto.h, list all the class member variables, which come in two main kinds:
      * options: fields that can be set from outside (like constructor arguments in ordinary C++)
       and define the functionality that is desired from the object. An option can also be
       a field that is the result of a computation and should be kept when an object is saved
       (e.g. the parameters of a trained model). These are called 'learnt' options by opposition
       to 'build' options which are used to build the object from scratch and should always
       be provided (unless the default value is acceptable).
      * auxiliary variables, temporary variables, etc..: fields that should not be set by the user
        but are constructed by the object in order to achieve its job. 

      The former (the options) should be in the 'public' section.
      The latter (the non-options) should be in a 'protected' section.

   * in Toto.cc, is where most of the action is:
      * the empty constructor should: call the inherited() empty constructor
        and initialize all fields which don't have automatic initialisation
        (e.g. ints, floats, ordinary pointers, etc..), and options default
        values.

      * a call to the PLEARN_IMPLEMENT_OBJECT macro, which provides a 1-line description
        of the class as well as a LONG description of the class, enough for a user to
        understand its functionality. Some details about specific options may be avoided
        here since these can be provided in the declareOptions method.

      * the definition of the declareOptions method: for each option one provides its name,
        (ideally the user accessible name should be the same as the C++ variable name),
        its type (typically either buildoption or learntoption), and most importantly,
        a text that clearly defines the functionality  of the option in the context of the class
        help (and of the other options), e.g. what different values represent, etc...
        Note that the default value (set in the empty constructor) will be shown 
        by the plearn help command so it is not necessary to give it here.

      * build(): this method should not be changed from the pyskeleton result; it allows
        inheritance of the "build constructors", and calls build_ which does the actual work.

      * build_(): this checks that the options are set in such a way that the object can
        be constructed (otherwise call PLERROR), and then goes about constructing the object
        (setting option and non-option fields, for example) so that it is ready to be used.
        NOTE THAT build/build_ can be called multiple times on the same object. There are
        different circumstances in which build can be called:
         * when creating an object from scratch, for the first time
         * after loading a saved object,
         * a 2nd or 3rd time after any of the above

      * makeDeepCopyFromShallowCopy: this makes sure that serialization / streaming work
         properly even if there are multiple pointers to the same thing within 
         the serialized object. It is very easy to write this method but it is VERY important
         to do it right. It should contain a sequence of calls to deepCopyField 
         (as shown in the Toto example) for EVERY CLASS MEMBER FIELD THAT IS OR CONTAINS 
         SOME KIND OF POINTER (including of course PLearn's smart pointers PP<...>, 
         vectors, matrices, etc...). To ease checking, it is suggested to list the
         fields in the same order as in the .h class declaration.
         

-- Main.YoshuaBengio - 18 Mar 2004
